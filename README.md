# SPI Slave With Single Port Memory
## SPI Architecture

![SPI Architechture](https://github.com/user-attachments/assets/c49a55ec-dc5a-42f0-a0ce-fd8f0bf92cc1)

## Project Overview
This project focuses on designing and implementing an SPI (Serial Peripheral Interface) Slave that interfaces with a Single Port RAM using Verilog HDL. The design comprises three main modules:

1- **SPI Slave**: Handles communication with the master device using the SPI protocol.
2- **Single Port RAM**: Provides efficient data storage and retrieval.
3- **Wrapper Module**: Integrates the SPI Slave and RAM, managing data flow between them.
The SPI Slave module is implemented using a Finite State Machine (FSM), where different FSM encoding schemes (Gray, Sequential, and One Hot) were explored to optimize performance and efficiency.

## SPI Communication Protocol
SPI, or Serial Peripheral Interface, is a synchronous serial communication protocol frequently used in embedded systems, microcontrollers, and other digital devices.
SPI is a full-duplex communication protocol, meaning data can be sent and received simultaneously, The protocol uses four main signals:

- **MOSI (Master Out Slave In)**: Transmits data from the master to the slave.
- **MISO (Master In Slave Out)**: Transmits data from the slave to the master.
- **SCLK (Serial Clock)**: A clock signal generated by the master to synchronize data transfer.
- **SS/CS (Slave Select/Chip Select)**: Enables the master to select the specific slave for communication with RAM.

## Project Components
1. **SPI_SLAVE.v**: Implements the SPI Slave.
   - **Ports**:

     | Name     | Type   | Size  | Stands for             |
     |----------|--------|-------|-------------------------|
     | MOSI     | Input  | 1 bit | Master Out Slave In     |
     | tx_valid | Input  | 1 bit | Control for Input Data  |
     | tx_data  | Input  | 8 bits| Input Data for SPI Slave|
     | rst_n    | Input  | 1 bit | Active low asynchronous reset |
     | clk      | Input  | 1 bit | Clock                   |
     | MISO     | Output | 1 bit | Data Output             |
     | rx_valid | Output | 1 bit | Control for Output Data |
     | rx_data  | Output | 10 bits| Output Data for SPI Slave |

2. **RAM.v**: Implements a single-port synchronous RAM.
   - **Parameters**:
     - `MEM_DEPTH`: Memory depth, default is 256.
     - `ADDR_SIZE`: Address size, default is 8 bits.
   - **Ports**:

     | Name     | Type   | Size  | Description             |
     |----------|--------|-------|-------------------------|
     | din      | Input  | 10 bits| Data Input             |
     | clk      | Input  | 1 bit | Clock                   |
     | rst_n    | Input  | 1 bit | Active low asynchronous reset |
     | rx_valid | Input  | 1 bit | If HIGH: accept din[7:0] to save the write/read address internally or write a memory word depending on the most significant 2 bits din[9:8] |
     | dout     | Output | 8 bits| Data Output             |
     | tx_valid | Output | 1 bit | Whenever the command is memory read the tx_valid should be High |

3. **SPI_Wrapper.v**: Connects the SPI Slave and RAM modules.
   - Handles the communication and data transfer between the SPI Slave and RAM.

## SPI Slave States

![Screenshot 2024-08-09 204812](https://github.com/user-attachments/assets/012de032-74f1-4bf8-8262-3f8716c152d3)

### 1. Write Address
1. Master starts the write command by sending the write address value, `rx_data[9:8] = din[9:8] = 2'b00`.
2. `SS_n = 0` to signal the SPI Slave that the master will begin communication.
3. SPI Slave checks the first received bit on the `MOSI` port which is a control bit to determine the operation (write in this case). The SPI Slave then expects to receive 10 bits, with the first 2 bits being "00" and the next 8 bits being the write address.
4. Data is converted from serial (MOSI) to parallel after writing to the `rx_data[9:0]` bus.
5. `rx_valid` will be HIGH (for one clock cycle) to inform the RAM to expect data on the `din` bus.
6. `din` takes the value of `rx_data`.
7. RAM checks `din[9:8]` and finds they hold "00".
8. RAM stores `din[7:0]` in the internal write address bus.
9. `SS_n = 1` to end communication from the master side.

### 2. Write Data
1. Master continues the write command by sending the write data value, `rx_data[9:8] = din[9:8] = 2'b01`.
2. `SS_n = 0` to signal the SPI Slave that the master will begin communication.
3. SPI Slave checks the first received bit on the `MOSI` port which is a control bit to determine the operation (write in this case). The SPI Slave then expects to receive 10 more bits, with the first 2 bits being "01" and the next 8 bits being the write data.
4. Data is converted from serial (MOSI) to parallel after writing to the `rx_data[9:0]` bus.
5. `rx_valid` will be HIGH (for one clock cycle) to inform the RAM to expect data on the `din` bus.
6. `din` takes the value of `rx_data`.
7. RAM checks `din[9:8]` and finds they hold "01".
8. RAM stores `din[7:0]` in the RAM with the previously held write address.
9. `SS_n = 1` to end communication from the master side.

### 3. Read Address
1. Master starts the read command by sending the read address value, `rx_data[9:8] = din[9:8] = 2'b10`.
2. `SS_n = 0` to signal the SPI Slave that the master will begin communication.
3. SPI Slave checks the first received bit on the `MOSI` port which is a control bit to determine the operation (read in this case). The SPI Slave then expects to receive 10 bits, with the first 2 bits being "10" and the next 8 bits being the read address.
4. Data is converted from serial (MOSI) to parallel after writing to the `rx_data[9:0]` bus.
5. `rx_valid` will be HIGH (for one clock cycle) to inform the RAM to expect data on the `din` bus.
6. `din` takes the value of `rx_data`.
7. RAM checks `din[9:8]` and finds they hold "10".
8. RAM stores `din[7:0]` in the internal read address bus.
9. `SS_n = 1` to end communication from the master side.

### 4. Read Data
1. Master continues the read command by sending the read data command, `rx_data[9:8] = din[9:8] = 2'b11`.
2. `SS_n = 0` to signal the SPI Slave that the master will begin communication.
3. SPI Slave checks the first received bit on the `MOSI` port which is a control bit to determine the operation (read in this case). The SPI Slave then expects to receive 10 bits, with the first 2 bits being "11" and the next 8 bits being dummy data, which will be ignored as the master waits for data from the slave.
4. Data is converted from serial (MOSI) to parallel after writing to the `rx_data[9:0]` bus.
5. `din` takes the value of `rx_data`.
6. RAM reads `din[9:8]` and finds they hold "11".
7. RAM reads from the memory with the previously held read address.
8. RAM asserts `tx_valid` to inform the slave that data output is ready.
9. Slave reads `tx_data` and converts it to serial output data on the `MISO` port.
10. `tx_valid` will be HIGH for 9 clock cycles (1+8).
11. `SS_n = 1` to end communication from the master side after receiving data for 8 clock cycles.

## Repository Structure:
- **Design Modules Folder** : Contains designs of SPI Slave, RAM and SPI Wrapper blocks
- **Testbenches Folder** : Contains Testbenches of all Design modules.
- **Images Folder** : Contains snippets of design simulation on Questasim and Vivado flow.
- **Project Documentation** : Contains Project Documentation  
- **Constraints file** : to burn the design on FPGA
- **Do file** : to run simulate easily on Questasim

## How to Run
1. Clone the repository
2. Open Vivado and load the project
3. Run the design flow:
      Synthesize the design.
      Implement the design.
      Generate the bitstream.
4. Simulation:
       use the provided Do file to run simulation easily.

## Conclusion
This project demonstrates a robust implementation of an SPI Slave with Single Port RAM, highlighting key digital design principles and efficient use of Verilog HDL. It serves as a solid foundation for further exploration and development in FPGA-based digital systems.

## Contact Me!
- [Email](mailto:shehabeldeen2004@gmail.com)
- [WhatsApp](https://wa.me/+2001142437518)
- [LinkedIn](www.linkedin.com/in/shehabeldeen22)
